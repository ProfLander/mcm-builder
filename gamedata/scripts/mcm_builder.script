assert(string.find(ui_mcm.VERSION, "1.%d.%d"), "MCM Builder: Unsupported MCM version")

AbstractOption = {
   -- Not an actual class, just a pile of methods used by
   -- everyone else

   input_type = function (self, typ)
      -- tells the script what kind of value 
      -- the option is storing / dealing with
      if typ == "string" then
         self.val = 0
      elseif typ == "boolean" then
         self.val = 1
      elseif typ == "float" then
         self.val = 2
      else
         assert(nil, "MCM Builder: unknown type: "..tostring(typ))
      end
      return self
   end,

   cmd = function (self, cmd)
      -- Tie an option to a console command
      -- Refer to MCM manual for the documentation
      assert(not self.def, "MCM Builder: default value does not work with cmd enabled")
      self.cmd = cmd
      return self
   end,

   default = function (self, def)
      -- value or table {function, parameters}
      -- Default value of an option
      assert(not rawget(self,"cmd"), "MCM Builder: default value does not work with cmd enabled")
      if type(def) == "table" then
         assert(type(def[1]) == "function", "MCM Builder: default table without a function")
      end
      self.def = def
      return self
   end,

   current_value = function (self, curr)
      -- table {function, parameters}
      -- get current value of an option by executing
      -- the declared function, instead of reading it from axr_options.ltx
      assert(type(curr[1]) == "function", "MCM Builder: current value without a function")
      self.curr = curr
      return self
   end,

   callback = function (self, tbl)
      -- table {function, parameters}
      -- Execute a function when option's changes get applied
		-- The value of the option is added to the end of the parameters list.
      assert(type(tbl[1]) == "function", "MCM Builder: callback without a function")
      self.functor = tbl
      return self
   end,

   text = function (self, text)
      -- String to show, it will be translated
      self.text = text
      return self
   end,

   hint = function (self, hint)
      -- Override default name / desc rule to replace
      -- the translation of an option with a custom one,
      -- should be set without "ui_mcm_" and "_desc"
      self.hint = hint
      return self
   end,

   color = function (self, r, g, b, a)
      -- determines the color of the text
      assert(type(a + r + g + b) == "number", "MCM: invalid color representation")
      self.clr = {a,r,b,g}
      return self
   end,

   minmax = function (self, min, max)
      -- Minimum/maximum for an option
      assert(self.val == 2, "MCM Builder: minmax does not work if input type is not float")
      assert(min + max, "MCM Builder: bad minmax values")
      self.min = min
      self.max = max
      return self
   end,

   content_pairs = function (self, content)
      -- table {double pairs}
      -- Declares option's selection list
      for _, v in ipairs(content) do
         assert(#v == 2, "MCM Builder: not a pair")
      end
      self.content = content
      return self
   end,

   image = function (self, link)
      -- Link to texture you want to show
      self.link = link
      return self
   end,

   dont_translate = function (self)
      -- Usually, the 2nd key of pairs in content table are
      -- strings to show on the UI, by translating "opt_str_lst_(string)".
		-- When we set [no_str] to true, it will show
      -- the string from table as it is without
      -- translations or "opt_str_lst_"
		-- For TrackBars: no_str won't show value next to the slider
      self.no_str = true
      return self
   end,

   precondition = function (self, prec)
      -- table {function, parameters}
      -- Show the option on UI if the precondition function returns true
      assert(type(prec[1]) == "function", "MCM Builder: precondition without a function")
      self.precondition = prec
      return self
   end,

   postcondition = function (self, postc)
      -- table {function, parameters}
      -- Option won't execute its functor when changes are applied,
      -- unless if the postcondition function returns true
      assert(type(postc[1]) == "function", "MCM Builder: postcondition without a function")
      self.postcondition = postc
      return self
   end,
}

--- Container for generalized MCM getters and setters
AbstractLens = {
   key = function(self)
      return table.concat(self.path, "/")
   end,

   get = function(self, d)
      local out = nil

      if ui_mcm then
         out = ui_mcm.get(self:key())
      end

      if out == nil and d then
         out = d(self.path)
      end

      if out == nil then
         out = self.def
      end

      return out
   end,

   set = function(self, v)
      if ui_mcm then
         ui_mcm.set(self:key(), v)
      end
   end,
}

Tree = {
   -- Structural element; You'll probably need at least one to start.
   -- Don't forget to :build() at the end.
   _cls = "Tree",

   new = function (id, collection)
     assert(type(id) == "string", "MCM Builder: no id given")
     local t = {
       id = id,
       path = {id},
       col = collection,
       sh = false,
       gr = {}
     }
     setmetatable(t, {__index = Tree})
     return t
   end,

   add_subtree = function (self, subtree)
      -- Add another Tree on the next MCM level
      assert(subtree._cls == "Tree", "MCM Builder: not a Tree")
      assert(not subtree._subtree, "MCM Builder: Tree too deep")
      subtree._subtree = true    -- only can add pages to subtree
      self._subtree = true      -- can't add self to another tree
      self.gr[#self.gr+1] = subtree
      return self
   end,

   add_page = function (self, page)
      -- Add Page. Page is final destination.
      assert(page._cls == "Page", "MCM Builder: not a Page")
      self.gr[#self.gr+1] = page
      return self
   end,

   build = function(self)
      -- Create a copy of our table minus OOP features and builder data
      local out = {}
      copy_table(out, self)
      out._subtree = nil

      -- Recurse on table children
      for _, v in pairs(self) do
         if type(v) == "table" then
            Tree.build(v)
         end
      end

      -- Done, return both the resulting struct
      -- and any collection ID that may be set on the tree
      return out, self.col
   end,

   group = function (self, group_id)
      -- allows you to give options tree a group id,
      -- to connect them when you want to use "Apply to all"
      -- button for options
      assert(type(group_id) == "string", "MCM Builder: not a text")
      self.id_gr = group_id
      self.apply_to_all = true
      return self
   end,

   collection = function(self, collection)
      --- Populate the collection ID field:
      --- If non-nil when `build` is called, the collection will be
      --- returned as its second value.
      --- If passed directly back to MCM, this will cause it to
      --- attach the resulting tree to an existing one with the given ID
      --- instead of creating a new root menu entry.
      assert(type(collection) == "string", "MCM Builder: no collection given")
      self.collection = collection
      return self
   end,

   --- Smart page constructor
   --- Variadic on both input and output for ergonomic multi-binding
   pages = function(self, ...)
      local ids = {...}
      local out = {}

      for i,id in ipairs(ids) do
         assert(id, string.format("Invalid page ID at index %s", i))
         local page = Page.new(id)
         self:add_page(page)
         page.path = {}
         copy_table(page.path, self.path)
         table.insert(page.path, id)
         table.insert(out, page)
      end

      ---Avoid spurious LSP complaints about x-ray's extended Lua 5.1
      ---@diagnostic disable-next-line: deprecated
      return unpack(out)
   end,

   --- Smart subtree constructor
   --- Variadic on both input and output for ergonomic multi-binding
   subtrees = function(self, ...)
      local ids = {...}
      local out = {}

      for i,id in ipairs(ids) do
         assert(id, string.format("Invalid tree ID at index %s", i))
         local tree = Tree.new(id)
         self:add_subtree(tree)
         tree.path = {}
         copy_table(tree.path, self.path)
         table.insert(tree.path, tree.id)
         table.insert(out, tree)
      end

      ---Avoid spurious LSP complaints about x-ray's extended Lua 5.1
      ---@diagnostic disable-next-line: deprecated
      return unpack(out)
   end,

   text = AbstractOption.text,
}

Page = {
   -- Final destination; Options are added to this one.
   -- Is added to a Tree, choosing it gives you the page
   -- You probably can use it without a Tree, if you only need
   -- one page.
   _cls = "Page",

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id=id, sh=true, gr={}}
      setmetatable(t, {__index = Page})
      return t
   end,

   add = function (self, widget)
      -- Add widget to self
      assert(widget._widget, "MCM Builder: Trying to add not a widget")
      self.gr[#self.gr+1] = widget
      return self
   end,

   merge = function (self, page)
      -- Add everything from another Page to self
      assert(page._cls == "Page", "MCM Builder: not a Page")
      for _, widget in pairs(page.gr) do
         self:add(widget)
      end
      return self
   end,

   precondition = AbstractOption.precondition,
   text_on_fail = function (self, text)
      -- Text to show when precondition fails
      assert(type(text) == "string", "MCM Builder: not a text")
      self.output = text
      return self
   end,

   --- Smart setting constructor
   --- Variadic on both input and output, for ergonomic multi-binding
   settings = function(self, ...)
      local settings = {...}
      local out = {}
      for i,setting in ipairs(settings) do
         assert(setting, string.format("Invalid setting at index %s", i))
         self:add(setting)
         setting.path = {}
         copy_table(setting.path, self.path)
         table.insert(setting.path, setting.id)
         table.insert(out, setting)
      end

      ---Avoid spurious LSP complaints about x-ray's extended Lua 5.1
      return unpack(out)
   end,


   group = Tree.group,
   text = AbstractOption.text,
   build = Tree.build,
}

Checkbox = {
   -- Literally boolean option, no bells and whistles
   _cls = "Checkbox",
   _widget = true,

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id=id, type = "check", val = 1}
      setmetatable(t, {__index = Checkbox})
      return t
   end,

   default = AbstractOption.default,
   hint = AbstractOption.hint,
   cmd = AbstractOption.cmd,

   precondition = AbstractOption.precondition,
   callback = AbstractOption.callback,
   postcondition = AbstractOption.postcondition,

   current_value = AbstractOption.current_value,

   key = AbstractLens.key,
   get = AbstractLens.get,
   set = AbstractLens.set,
}

List = {
   -- List of strings, useful for options with too many selections
   _cls = "List",
   _widget = true,

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id=id, type = "list", val = 0}
      setmetatable(t, {__index = List})
      return t
   end,

   content = function (self, tbl)
      self.content = tbl
      return self
   end,

   default = AbstractOption.default,
   content_pairs = AbstractOption.content_pairs,
   input_type = AbstractOption.input_type,
   cmd = AbstractOption.cmd,
   dont_translate = AbstractOption.dont_translate,

   precondition = AbstractOption.precondition,
   callback = AbstractOption.callback,
   postcondition = AbstractOption.postcondition,

   current_value = AbstractOption.current_value,
   hint = AbstractOption.hint,

   key = AbstractLens.key,
   get = AbstractLens.get,
   set = AbstractLens.set,
}

InputField = {
   -- Input box, you can type a value of your choice
   _cls = "InputField",
   _widget = true,

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id = id, type = "input", val = 0}
      setmetatable(t, {__index = InputField})
      return t
   end,

   default = AbstractOption.default,
   minmax = AbstractOption.minmax,
   input_type = AbstractOption.input_type,
   cmd = AbstractOption.cmd,

   precondition = AbstractOption.precondition,
   callback = AbstractOption.callback,
   postcondition = AbstractOption.postcondition,

   current_value = AbstractOption.current_value,
   hint = AbstractOption.hint,

   key = AbstractLens.key,
   get = AbstractLens.get,
   set = AbstractLens.set,
}

RadioBox = {
   -- Radio box, select one out of many choices.
   _cls = "RadioBox",
   _widget = true,

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id = id, type = "radio_h", val = 0}
      setmetatable(t, {__index = RadioBox})
      return t
   end,

   vertical = function (self)
      -- Makes vertical, lol
      self.type = "radio_v"
      self.force_horz = nil
      return self
   end,

   force_horizontal = function (self)
      -- Force the radio buttons into horizental layout,
      -- despite their number
      assert(self.type == "radio_h", "MCM Builder: force_horizontal on vertical radiobox")
      self.force_horz = true
      return self
   end,

   input_type = AbstractOption.input_type,
   cmd = AbstractOption.cmd,
   dont_translate = AbstractOption.dont_translate,

   precondition = AbstractOption.precondition,
   callback = AbstractOption.callback,
   postcondition = AbstractOption.postcondition,

   current_value = AbstractOption.current_value,
   hint = AbstractOption.hint,

   key = AbstractLens.key,
   get = AbstractLens.get,
   set = AbstractLens.set,
}

Trackbar = {
   -- Track bar, easy way to control numeric options with min/max values
   _cls = "Trackbar",
   _widget = true,

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id=id, type = "track", val = 2, min = 0, max = 2, step = 0.1, def = 1}
      setmetatable(t, {__index = Trackbar})
      return t
   end,

   step = function (self, step)
      -- USE increment INSTEAD! THIS ONE WILL CRASH.
      assert(type(step) == "number", "MCM Builder: step is not a number")
      self.step = step
      return self
   end,

   increment = function (self, step)
      -- Set step
      assert(type(step) == "number", "MCM Builder: step is not a number")
      self.step = step
      return self
   end,

   precision = function (self, prec)
      -- allowed number of zeros in a number
      self.prec = prec
      return self
   end,

   minmax = AbstractOption.minmax,
   default = AbstractOption.default,
   cmd = AbstractOption.cmd,
   dont_translate = AbstractOption.dont_translate,

   precondition = AbstractOption.precondition,
   callback = AbstractOption.callback,
   postcondition = AbstractOption.postcondition,

   current_value = AbstractOption.current_value,
   hint = AbstractOption.hint,

   key = AbstractLens.key,
   get = AbstractLens.get,
   set = AbstractLens.set,
}

KeybindBox = {
   -- Button that registers a keypress after being clicked.
   _cls = "KeybindBox",
   _widget = true,

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id=id, type = "key_bind", val = 2}
      setmetatable(t, {__index = KeybindBox})
      return t
   end,

   cmd = AbstractOption.cmd,
   precondition = AbstractOption.precondition,
   hint = AbstractOption.hint,
   default = AbstractOption.default,

   key = AbstractLens.key,
   get = AbstractLens.get,
   set = AbstractLens.set,
}


Line = {
   -- Literally a useless line
   _cls = "Line",
   _widget = true,

   new = function ()
      local t = {id = "line", type = "line"}
      setmetatable(t, {__index = Line})
      return t
   end,
}

Image = {
   -- Literally a useless image
   _cls = "Image",
   _widget = true,

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id=id, type="image"}
      setmetatable(t, {__index = Image})
      return t
   end,

   image = AbstractOption.image,
}

ImageWithText = {
   -- Useless image on the left, maybe useful text on the right
   _cls = "ImageWithText",
   _widget = true,

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id=id, type="slide", size={512,50}}
      setmetatable(t, {__index = ImageWithText})
      return t
   end,

   size = function (self, size)
      -- custom size for the texture
      assert(#size == 2, "MCM Builder: unknown size type")
      self.size = size
      return self
   end,

   stretch = function (self)
      -- force the texture to stretch or not
      self.stretch = true
      return self
   end,

   position = function (self, x, y)
      -- position
      assert(x + y, "MCM Builder: bad position arguments")
      self.pos = {x, y}
      return self
   end,

   v_offset = function (self, offset)
      -- height offset to add extra space
      assert(type(offset) == "number", "MCM Builder: offset is not a number")
      self.spacing = offset
      return self
   end,

   image = AbstractOption.image,
   text = AbstractOption.text,
}

Title = {
   -- Big Fucking Text
   _cls = "Title",
   _widget = true,

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id = id, type = "title", align = "c"}
      setmetatable(t, {__index = Title})
      return t
   end,

   align = function (self, str)
      -- determines the alignment of the title
      if str == "center" then
         self.align = 'c'
      elseif str == "right" then
         self.align = 'r'
      elseif str == "left" then
         self.align = 'l'
      else
         assert(nil, "MCM Builder: unknown alignment: "..str)
      end

      return self
   end,

   color = AbstractOption.color,
   text = AbstractOption.text,
}

Description = {
   -- Small text, left alignment
   _cls = "Description",
   _widget = true,

   new = function (id)
      assert(type(id) == "string", "MCM Builder: no id given")
      local t = {id = id, type = "desc"}
      setmetatable(t, {__index = Description})
      return t
   end,

   text = AbstractOption.text,
}

--- Getter fallback for retrieving defaults
--- from a table with comparable structure.
---
--- Not actually that useful in light of controls storing
--- their own defaults and being able to fall back on those,
--- but included for didactic purposes.
--- (And because default tables are a common pattern.)
---
---@param tbl table
---@return fun(path: table): any
default_table = function(tbl)
   return function(path)
      local focus = tbl
      for i,k in ipairs(path) do
         focus = focus[k]
         assert(focus ~= nil, string.format("Invalid key at index %s: %s", i, k))
      end
      return focus
   end
end
